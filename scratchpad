#        r.images=[]
#        r.making_processes=[]


if (1==2):
    pass

#    m.bibliographic_information[0].persons[0].



#    await r.insert(link_rule=WriteRules.WRITE)
#    r.fetch_link
#    pl=DBRef("all_collections",r.id)
#    rr=Link()
#    rr.document_class=classes.BibliographicInformation()
#    rr.

#    DBRef
#    pl=Link(ref = bi.id, document_class=classes.Role)
#    bi.persons.append(r)
#    print(bi)
#    await bi.insert(link_rule=WriteRules.DO_NOTHING)
#    print(bi.id)
#    print(type(bi.id))
#    xx= await classes.BibliographicInformation.get(document_id=bi.id,fetch_links=True)

#    print(xx)

#xx =  classes.Person.find(classes.Person.gnd_id == "12345421")

#print(await xx.to_list())

# xx = classes.Role.find(classes.Role.entity_and_connections.person.gnd_id == "12345421",fetch_links=True)

# print(await xx.to_list())



 
#        r.bibliographic_information=None

        # r.bibliographic_id=[]
#        r.bibliographic_information[0].places=[]
#        print(r.bibliographic_information[0].persons[0])
        # r.bibliographic_information[0].persons=[]
#        await r.bibliographic_information[0].persons[0].insert(link_rule=WriteRules.WRITE)
#        print("role inserted")

    #    print(r.bibliographic_information[0].person   s[0])
#        r.].bibliographic_information=[]
#        r.bibliographic_information[0].model_validate()
#        classes.Metadata.model_validate(r)

    #    x = await r.bibliographic_information[0].persons[0].insert(link_rule=WriteRules.WRITE)
#        r.repository=None
    #   print(r)

#        r.bibliographic_information[0].persons=[]
#        print(r.bibliographic_information[0].persons[0])
#        await r.bibliographic_information[0].persons[0].save(link_rule=WriteRules.WRITE)

#        r.bibliographic_information[0].places=[]
#        print(r.bibliographic_information[0].persons[0])
#        r.bibliographic_information[0]=[]
        
#        await r.bibliographic_information[0].save()
#        print(r)
#        x=await r.save(link_rule=WriteRules.WRITE)
        
#        xx=x.id
        # xx="66d28c1b59c36fe27fc66ace"
        # print("AFTER SAVING")
        # x=await classes.Metadata.get(xx,fetch_links=True)
        # x.images=[]
        # print(x)

        # print(x.id)
        # print(x.type)
        # b = await book_ingest_create_records.populate_book_from_metadata(x)
        # print(b)
        # await b.save(link_rule=WriteRules.WRITE)
#        (x)


#    r = await app_main.get_metadata(iiif_url,material)
#    f = open("herbarius_metadata.json","w")
#    f.write(r.model_dump_json()) 
#    f.close()

#    f = open("herbarius_metadata.json","r")
#    m = f.read()
#    meta = classes.Metadata.model_validate_json(m)
#    i = await app_main.save_connected_records(meta)
#    print(r)

#    bid_name="GW"
#    bid_id="12268"
#    bibliographic_information_single = await parse_iiif.select_bibliography(bid_name, bid_id)

#        url_bibliography = r'https://data.cerl.org/istc/_search?_format=json&pretty=false&query=reference%3A%22GW ' + gw_number + r'%22&size=10&sort=default&from=0&file=false&orig=true&facet=dimensions&facet=printingcountry&facet=holdingcountry&nofacets=true&mode=default&aggregations=true&style=full'
#        bibliographic_information_single = await books_parsing_bibliographies.parse_istc(url_bibliography) 


#    external_id = classes.ExternalId()
#    external_id.name = "viaf"
#    external_id.id = "128386719"
#        person_selected = person.potential_candidates[person.chosen_candidate]


#        for connected_person in person_selected.connected_persons:
    #for external_id in connected_person.external_id:
#                person_found = coll.find_one({"external_id": {"$elemMatch": {"name": external_id.name, "id": external_id.id}}}, {"id": 1, "name_preferred" : 1, "sex" : 1, "connected_persons" : 1})
#    person_found = db_actions.find_person(external_id,"external_id")
#        person_found = collection.find_one({"external_id": {"$elemMatch": {"name": person.id_name, "id": person.id}}}, {"id": 1, "person_type1": 1, "name_preferred": 1})
#    person_found = db_actions.find_person(person,"external_id")
#    print(person_found)
#    r = await classes.PersonDb.find_one(classes.PersonDb.external_id.id == external_id.id 
#                              and classes.PersonDb.external_id.name == external_id.name)
#    r=r.project(classes.PersonDb)
#    rr=classes.PersonDb()
# #   rr=r
#    print(r)
#    schoeffer_json='{"id":"","id_name":"","internal_id":"","internal_id_person_type1":[],"internal_id_person_type1_needed":"Printer","internal_id_person_type1_comment":"","internal_id_preview":"","name":"Peter Schoeffer","role":"prt","chosen_candidate":0,"potential_candidates":[{"external_id":[{"uri":"https://d-nb.info/gnd/118609947","name":"GND","id":"118609947"}],"internal_id":"","internal_id_person_type1":[],"internal_id_person_type1_comment":"","name_preferred":"Schöffer, Peter","name_variant":["Schöffer, Peter (der Ältere)","Peter (Schöffer)","Schoeffer, Peter","Schöffer, Petrus","Scheffer, Peter","Scheffer, Petrus","Schoffer, Petrus","Schoiffer, Petrus","Schoyffer, Petrus","Schoiffer de Gernheym, Petrus","Gernheym, Petrus Schoiffer de","Schoyffer de Gernheym, Petrus","Gernheym, Petrus, Schoyffer de","Gernssheym, Petrus","Schoiffer de Gernßhem, Petrus","Gernßhem, Petrus Schoiffer de"],"sex":"male","dates_from_source":[{"datestring_raw":"1420-1502","date_comments":"","datetype":"datl","datestring":"","date_start":[],"date_end":[],"date_aspect":""}],"datestring":"","date_start":[],"date_end":[],"date_aspect":"","connected_persons":[{"id":"","external_id":[{"uri":"https://d-nb.info/gnd/118795295","name":"GND","id":"118795295"}],"name":"Schöffer, Peter","connection_type":"bezf","connection_comment":"Sohn","connection_time":""}],"connected_organisations":[],"connected_locations":[{"id":"","external_id":[{"uri":"https://d-nb.info/gnd/4020399-2","name":"GND","id":"4020399-2"}],"name":"Gernsheim","connection_type":"ortg","connection_comment":"","connection_time":""},{"id":"","external_id":[{"uri":"https://d-nb.info/gnd/4037124-4","name":"GND","id":"4037124-4"}],"name":"Mainz","connection_type":"ortw","connection_comment":"","connection_time":"1457-1502"}],"comments":"Dt. Druckerverleger, Mitarbeiter und fähigster Schüler Gutenbergs. - Aus Germsheim, studierte an der Universität Paris und kam 1452 nach Mainz. Stand im Streit zwischen Fust und Gutenberg auf Seiten Fusts; mit seiner Hilfe konnte Fust den Betrieb weiterführen. Während Schöffer die Druckerei leitete, besorgte Fust den Buchhandel. Nach Fusts Tod 1466 heiratete Schöffer Fusts Tochter Christine und wurde dadurch neben anderen Erben Fusts Mitbesitzer des Unternehmens.; Drucker; Buchdrucker; Verleger","preview":"Schöffer, Peter (1420-1502), born in Gernsheim, active in Mainz, also called: Schöffer, Peter (der Ältere); Peter (Schöffer); Schoeffer, Peter; Schöffer, Petrus; Scheffer, Peter; Scheffer, Petrus; Schoffer, Petrus; Schoiffer, Petrus; Schoyffer, Petrus; Schoiffer de Gernheym, Petrus; Gernheym, Petrus Schoiffer de; Schoyffer de Gernheym, Petrus; Gernheym, Petrus, Schoyffer de; Gernssheym, Petrus; Schoiffer de Gernßhem, Petrus; Gernßhem, Petrus Schoiffer de (Dt. Druckerverleger, Mitarbeiter und fähigster Schüler Gutenbergs. - Aus Germsheim, studierte an der Universität Paris und kam 1452 nach Mainz. Stand im Streit zwischen Fust und Gutenberg auf Seiten Fusts; mit seiner Hilfe konnte Fust den Betrieb weiterführen. Während Schöffer die Druckerei leitete, besorgte Fust den Buchhandel. Nach Fusts Tod 1466 heiratete Schöffer Fusts Tochter Christine und wurde dadurch neben anderen Erben Fusts Mitbesitzer des Unternehmens.; Drucker; Buchdrucker; Verleger)"}],"new_authority_id":""}'
#    print(schoeffer_json)
#    print("importing json")
#    p=classes.Person()
#    p.model_validate_json(schoeffer_json)
#    print(p)
#    print("string")

#user_dict = json.loads(json_raw)
#user = User(**user_dict)
#    d = json.loads(schoeffer_json)
#    p = classes.Person(**d)
#    print(p)
#    pp = await ingest_person.ingest_person(p)

#    x=classes.Metadata()

#    uri_entered="https://api.digitale-sammlungen.de/iiif/presentation/v2/bsb00027407/manifest"
#    r= await parse_iiif.parse_iiif(uri_entered,"b")


#    uri_entered="https://api.digitale-sammlungen.de/iiif/presentation/v2/bsb00027407/manifest"
#    m= await get_external_data.get_web_data_as_json(uri_entered)
#    f = open("herbarius_manifest.json","w")
#    json.dump(m,f)
#    f.close()


#    await parse_iiif.parse_iiif(uri_entered,"b")
#    m=classes.Metadata()
#§    m=await app.get_metadata(uri_entered,"b")
#    m="asdf"    
#    m.model_dump_json()
#    print(m.model_dump_json())
#    json.dumps(m)
#    print(type(m))

#    f = open("herbarius_metadata.json","r")
#    m = f.read()
#    print(m)
#    m=json.load(f)
#    m=json.load(f)
#    print(m)
#    manifest = classes.Metadata(**m)
#    manifest=m
#    print("PRINTING MANIFEST")
#    print(manifest)
#    parse_manifests.parse_manifests_bsb(manifest)

#    with open('herbarius_metadata.pkl', 'wb') as f: 
#        pickle.dump([m], f)

#    with open('herbarius_metadata.pkl', 'rb') as f:
#        m = pickle.load(f)
    
#    print("pretty printing")
#    print(m)
#    print(type(m))
#    mm=classes.Metadata(m)
#    pprint.pp(m)
#    m.bibliographic_information[0]
#    url_search_list=["https://viaf.org/viaf/sourceID/DNB%7C040203999"]
#    async with aiohttp.ClientSession() as session:
#        results = await asyncio.gather(*(get_viaf_header(session, url) for url in url_search_list))
#    viaf_urls_dict = dict(zip(url_list, results))
#    t=classes.PagesDb()
#    manifest= await get_external_data.get_web_data_as_json(uri_entered)

#    uri_entered="https://api.digitale-sammlungen.de/iiif/presentation/v2/bsb00027407/manifest"
#    r= await parse_iiif.parse_iiif(uri_entered,"b")
#    print(r)
#    f = open("datetest.txt","r")
#    m = f.read()
#     d="29.02.1456-zwischen 10.09. und Oktober 1527"
#     d=d.lower()
#     dd=parse_date_1.get_date_aspect(d)
#     dd=re.sub("\d","",dd)
# #            dd=parse_date_1.remove_tags(dd)
# #            r=parse_date.parse_date_range(d)
#     print(dd,end="\n")
# #           


def test_date():
    if 1==2:

        f = open("date_results.txt","w")

        l=0
        succ=0
        succ_indiv=0
        filename="datestest.txt"
        with open(filename) as file:
            for line in file:
                l=l+1
    #            print(line)
                d=line.rstrip()
#                print(line.rstrip(),end=" ")
 #               d=d.lower()
#                dd=parse_date_1.get_date_aspect(d)
    #            dd=re.sub("\d","",dd)
                #dd=parse_date_1.remove_tags(dd)
                if not re.match("oder",d):
                    ddd=parse_date.parse_date_overall(d,"","")

                r=parse_date_1.parse_date_range(d)
#                print(dd,end=" ")
#                print(type(str(ddd)))
                if(r.state=="FAIL"):
                    print("Line ",end=" ")
                    print(l,end=" ")
                    print(d)
                    print(str(ddd))
                    print(r)
                
                if(r.state=="FAIL" or r.start.state=="FAIL" or r.end.state=="FAIL"):
                    f.write(d)
                    f.write(" ")
                    f.write("\n")
                    f.write(r.start.model_dump_json())
                    f.write("\n")
                    f.write(r.end.model_dump_json())
                    f.write("\n")
                    f.write(r.model_dump_json())
                    f.write("\n")
                    f.write(str(ddd))
                    f.write("\n")
                if r.state == "SUCCESS":
                    if r.start.state == "SUCCESS":
                        succ_indiv=succ_indiv+1
                    if r.end.state == "SUCCESS":
                        succ_indiv
    #                print("SUCCESS")
    #                print(d)
    #                print(r.start)
    #                print(r.end)
                    succ=succ+1
        print("Successes:")
        print(succ,succ/l)
        print("Individual Successes:")
        print(succ_indiv,succ_indiv/l/2)

    d="-18.04.1605"
    d="09.07.1867-XX.XX.19XX"
    d="29.02.1456-zwischen 10.09. und Oktober 1527"
 #   d="0X.02.1825-05.08.1895"
 #   d="1. Drittel 20. Jh."
 #   d="ca. 20. - 21. Jh."
    d="2. h. 17. Jh."
    d="* ?.?.1797-29.04.1868"
    d="*x.x.1234"
#    d="*x.x.1234"
#    d="10. Jh.-"
#    print(parse_date_1.replace_substring(d,"[*]","asdf"))
#    print(d)
    #d="1234-1234"
#    print(d)
#    r=parse_date_1.parse_date_range(d)
#    print(r)

#    r=parse_date.parse_date_overall(d,"","")
#    print(r)


async def url_test(uri_entered):
    d=await get_external_data.get_web_data_as_json(uri_entered)
    print("type of return from external_data")
    print(type(d))
    url = urllib.request.urlopen(uri_entered)
    ds=url.read()
    print("type of urllib result")
    print(type(ds))




async def play_make_meta():
    p=classes.Person()
    p.name="Test"

    ei=classes.ExternalReference()
    ei.name="external"
    p.external_id.append(ei)

    p2=classes.Person()
    p2.name="connected"

    ce=classes.EntityConnection()
    ce.name="test"
    ce.person=p2

    pac=classes.EntityAndConnections()
    pac.person=p
    pac.comment="test"
    pac.connected_persons.append(ce)
 
#    a=classes.BibliographicId()
#    a.id=generate()
    #a.name="asdf"
#    a.uri="fdsa"
    #a.bib_id="123"
#    await a.validate_self()
#    print(a)
#    classes.BibliographicId.model_validate(a)
#    a.model_validate(c)
#    print("a VALIDATED")
#    print("")
#    print("")
#    print("")



    mainp=classes.Person()
    mainp.name="main person"
#    await mainp.save(link_rule=WriteRules.WRITE)
    er1=classes.ExternalReference()
    er1.name="er1"
    mainp.external_id.append(er1)

    eac=classes.EntityAndConnections()
    eac.name="eac"
    eac.person=mainp
#    await eac.insert(link_rule=WriteRules.WRITE)

    otherp=classes.Person()
    otherp.name="otherp"
#    await otherp.save()

    ec=classes.EntityConnection()
    ec.name="ec"
    ec.person=mainp

    eac.connected_persons.append(ec)

#    await eac.save(link_rule=WriteRules.WRITE)
#    print(eac)
#    id=eac.id
#    xx= await classes.EntityAndConnections.get(id,fetch_links=True)
#    print("GETTING")
#    print(xx)

    r=classes.Role()
    r.role="test role"
    r.entity_and_connections=eac
 #   await r.save(link_rule=WriteRules.WRITE)

#    print("ROLE")
#    print(r)

    rr=classes.Role()
    rr.role="test role 2"
    rr.entity_and_connections=eac

    pl=classes.Place()
    pl.name="place test"
 #   await pl.save()
    pleac=classes.EntityAndConnections()
    pleac.place=pl
 #   await pleac.save(link_rule=WriteRules.WRITE)
    plr=classes.Role()
    plr.role="place role"
    plr.entity_and_connections=pleac
 #   print("")
 #   print(plr)
 #   print("")
 #   await plr.save(link_rule=WriteRules.WRITE)


    bi=classes.BibliographicInformation()
#    bi.id=generate()
    bi.title="bib info"
    bi.persons.append(r)
    bi.persons.append(rr)
    bi.places.append(plr)
#    print(bi)
#    await bi.save(link_rule=WriteRules.WRITE)

    m = classes.Metadata()
    m.bibliographic_information.append(bi)

    await m.save(link_rule=WriteRules.WRITE)

#    id=m.id

#    m = await classes.Metadata.get(document_id=id,fetch_links=True)

#    print(m)
   #     print(pac)
    #     print("SAVING")
    #     x = await pac.insert(link_rule=WriteRules.WRITE)
    #     print(x)
    #     id=x.id
    #     print("SEARCHING")
    #     xx= await classes.EntityAndConnections.get(id,fetch_links=True)
    #     print(type(xx))
    # #    xx.comment="asdf"
    #     xx.person.name="asdfaASDFD"
    #     await xx.save(link_rule=WriteRules.WRITE)
    #    xxx=xx.
    # #    project(classes.PersonAndConnections)
    #    print(xx) 

    # xx= classes.EntityAndConnections.find(\
    #     classes.EntityAndConnections.person.name=="asdfaASDFD" and\
    #     classes.EntityAndConnections.connected_persons.person.name=="nonono",\
    #     fetch_links=True)
    # print(xx)
    # print(await xx.count())
    # print(await xx.to_list())



